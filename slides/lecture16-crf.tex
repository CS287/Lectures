\begin{frame}
  \begin{center}
   
  \begin{tikzpicture}
    \Lattice

    \draw[blue] (network-1-3.east) -- (network-1-4.west);
    \draw[blue] (network-1-3.east) -- (network-2-4.west); 
    \draw[blue] (network-1-3.east) -- (network-3-4.west);
    \draw[blue] (network-1-3.east) -- (network-4-4.west);

    \draw[red] (network-1-3.west) -- (network-1-2.east);
    \draw[red] (network-1-3.west) -- (network-2-2.east); 
    \draw[red] (network-1-3.west) -- (network-3-2.east);
    \draw[red] (network-1-3.west) -- (network-4-2.east);

    \foreach \i in {1,...,4} {
    \foreach \j in {1,...,4} {
    \draw[red] (network-\i-1.east) -- (network-\j-2.west);
    % \draw[red] (network-\i-2.east) -- (network-\j-3.west);
    % \draw[red] (network-\i-3.east) -- (network-\j-4.west);
    \draw[blue] (network-\i-4.east) -- (network-\j-5.west);
    } }

  \end{tikzpicture}
  \end{center}  
\end{frame}


\begin{frame}{Edge Marginal}
  \begin{center}
   
  \begin{tikzpicture}
    \Lattice

    \draw[blue] (network-3-4.east) -- (network-1-5.west);
    \draw[blue] (network-3-4.east) -- (network-2-5.west); 
    \draw[blue] (network-3-4.east) -- (network-3-5.west);
    \draw[blue] (network-3-4.east) -- (network-4-5.west);
    \draw[black] (network-1-3.east) -- (network-3-4.west);

    \draw[red] (network-1-3.west) -- (network-1-2.east);
    \draw[red] (network-1-3.west) -- (network-2-2.east); 
    \draw[red] (network-1-3.west) -- (network-3-2.east);
    \draw[red] (network-1-3.west) -- (network-4-2.east);

    \foreach \i in {1,...,4} {
    \foreach \j in {1,...,4} {
    \draw[red] (network-\i-1.east) -- (network-\j-2.west);
    % \draw[red] (network-\i-2.east) -- (network-\j-3.west);
    % \draw[red] (network-\i-3.east) -- (network-\j-4.west);
    % \draw[blue] (network-\i-4.east) -- (network-\j-5.west);
    } }

  \end{tikzpicture}
  \end{center}  
\end{frame}


\begin{frame}
  
\end{frame}




\begin{frame}
  \begin{center}
   
  \begin{tikzpicture}
    \Lattice
    \foreach \i in {1,...,4} {
    \foreach \j in {1,...,4} {
    \draw[red] (network-\i-1.east) -- (network-\j-2.west);
    \draw[red] (network-\i-2.east) -- (network-\j-3.west);
    \draw[red] (network-\i-3.east) -- (network-\j-4.west);
    \draw[red] (network-\i-4.east) -- (network-\j-5.west);
    } }

    % \draw[red] (network-1-3.west) -- (network-1-2.east);
    % \draw[red] (network-1-3.west) -- (network-2-2.east); 
    % \draw[red] (network-1-3.west) -- (network-3-2.east);
    % \draw[red] (network-1-3.west) -- (network-4-2.east);

  \end{tikzpicture}
  \end{center}  
  
\end{frame}

\begin{frame}
  \begin{center}
   
  \begin{tikzpicture}
    \Lattice
    \foreach \i in {1,...,4} {
    \foreach \j in {1,...,4} {
    \draw<1->[red] (network-\i-1.east) -- (network-\j-2.west);
    \draw<2->[red] (network-\i-2.east) -- (network-\j-3.west);
    \draw<3->[red] (network-\i-3.east) -- (network-\j-4.west);
    \draw<4->[red] (network-\i-4.east) -- (network-\j-5.west);
    \draw<8->[blue] (network-\i-1.east) -- (network-\j-2.west);
    \draw<7->[blue] (network-\i-2.east) -- (network-\j-3.west);
    \draw<6->[blue] (network-\i-3.east) -- (network-\j-4.west);
    \draw<5->[blue] (network-\i-4.east) -- (network-\j-5.west);

    } }
  \end{tikzpicture}
  \end{center}  
\end{frame}


\begin{frame}
  \begin{center}
   
  \begin{tikzpicture}
    \Lattice
    \foreach \i in {1,...,4} {
    \foreach \j in {1,...,4} {
    \draw<8->[blue] (network-\i-1.east) -- (network-\j-2.west);
    \draw<7->[blue] (network-\i-2.east) -- (network-\j-3.west);
    \draw<6->[blue] (network-\i-3.east) -- (network-\j-4.west);
    \draw<5->[blue] (network-\i-4.east) -- (network-\j-5.west);
    } }
  \end{tikzpicture}
  \end{center}  
  
\end{frame}


\begin{frame}{Forward Algorithm}
  \begin{algorithmic}
    \Procedure{Forward}{}
    \State{$\alpha \in \reals^{\{0,\ldots, n\} \times \mcC}$ initialized to $-\infty$ }
    \State{$\alpha[0, \langle s \rangle] = 0$}
    \For{$i = 1$ to $n$ }
    \For{$c_{i} \in \mcC$}
    \State{$\alpha[i, c_i] = \sum_{c_{i-1}} 
     \alpha[i-1, c_{i-1}] * \hat{\boldy}(c_{i-1})_{c_i}        
       $}
    \EndFor{}
    \EndFor{}
    \State{\Return{$\sum_{c_n\in\mcC} \alpha[n, c_n]$}}
    \EndProcedure{}
  \end{algorithmic}
\end{frame}


\begin{frame}{Backward Algorithm}
  \begin{algorithmic}
    \Procedure{Backward}{}
    \State{$\beta \in \reals^{\{1,\ldots, n+1\} \times \mcC}$ initialized to $-\infty$ }
    \State{$\beta[n+1, \langle s \rangle] = 0$}
    \For{$i = n$ to $1$ }
    \For{$c_{i} \in \mcC$}
    \State{$\beta[i, c_i] = \sum_{c_{i+1}} 
     \beta[i+1, c_{i+1}] * \hat{\boldy}(c_{i})_{c_i+1}        
       $}
    \EndFor{}
    \EndFor{}
    \State{\Return{$\sum_{c_1\in\mcC} \beta[1, c_1]$}}
    \EndProcedure{}
  \end{algorithmic}
\end{frame}





\begin{frame}{Marginals}

  \[M(c_i) =  \sum_{c_{1:n}} f(\boldx, c_{1:n}) \] 
  
  % \[ \frac{\partial M}{\partial } \]

\end{frame}


\begin{frame}{Probabilistic }
  \[ p(\boldy_i = c_i | \boldx) = \sum_{c_i} p( \boldy_i = \delta(c_i) | \boldx_{1:n})  \] 

  For the case of MEMM gives you just this. 


  For HMM
  \begin{eqnarray*}
     p(\boldy_i = c_i | \boldx) &=& \sum_{c_i} p( \boldy_i = \delta(c_i) | \boldx_{1:n})  \\
     &= & p(\boldy_i = c_i | \boldx) = \sum_{c_i} p( \boldy_i = \delta(c_i), \boldx_{1:n}) / p(\boldx_{1:n})   
  \end{eqnarray*}

  How do you compute $p(\boldx_{1:n})$?
  % \[M(c_i) =  \sum_{c_{1:n}} f(\boldx, c_{1:n}) \] 
  
  % \[ \frac{\partial M}{\partial } \]

\end{frame}

\begin{frame}
  \[ p(\boldx_{1:n}) = \sum_{c_i}  \] 
\end{frame}


\begin{frame}{Edge Marginals}

  \[M(c_{i-1}, c_i) =  \sum_{c_{1:n}} f(\boldx, c_{1:n}) \] 
  
  % \[ \frac{\partial M}{\partial } \]

\end{frame}

\begin{frame}{}
  Is this the same forward-backward? 
\end{frame}


\begin{frame}{Viterbi}
  
  

\end{frame}



\section{Viterbi}
